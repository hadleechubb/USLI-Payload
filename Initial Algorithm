int finalLoc(String fileName, float frequency, float xVel0, float yVel0, float zVel0, float xDist0, float yDist0, float zDist0, float xThe0, float yThe0, float zThe0, float xOff, float yOff) //File on the SD card. It should have the x, y, and z accelerations in the 1st column and the x, y, z angular velocities in the 2nd column. Include frequency in Hz

  {

    float[] num = //Insert line of code here to pull data from the SD card and save it into the array called num

 

    float[] xAcc = new float[sizeof(num[1])/3)]; //Initializing acceleration arrays

    float[] yAcc = new float[sizeof(num[1])/3)];

    float[] zAcc = new float[sizeof(num[1])/3)];

    float[] xAcca = new float[sizeof(num[1])/3)]; //Initializing absolute acceleration arrays

    float[] yAcca = new float[sizeof(num[1])/3)];

    float[] zAcca = new float[sizeof(num[1])/3)];

    float[] xOme = new float[sizeof(num[1])/3)];

    float[] yOme = new float[sizeof(num[1])/3)];

    float[] zOme = new float[sizeof(num[1])/3)];

    float[] curtime = new float[sizeof(num[1])/3)]; //Initializing time array

    t = 1/frequency; //Finds time step process

   

    counter = 0;

    for(int i = 0; i < (sizeof(num[1])-1); i = i + 3)

    {

    xAcc[i] = num[i, 1];

    yAcc[i] = num[i+1, 1];

    zAcc[i] = num[i+2, 1];

    xOme[i] = num[i, 2];

    yOme[i] = num[i+1, 2];

    zOme[i] = num[i+2, 2];

        if(counter == 0)

        {

            curtime[counter] = 0;

        }

        else

        {

            curtime[counter] = curtime[counter-1] + t;

        }

        counter++;

    }

  

   

    

    float[] xVel = new float[sizeof(xAcc)-1]; //Initializing velocity arrays

    float[] yVel = new float[sizeof(yAcc)-1];

    float[] zVel = new float[sizeof(zAcc)-1];

    xVel[0] = xVel0;

    yVel[0] = yVel0;

    zVel[0] = zVel0;

   

    float[] xDist = new float[sizeof(xVel)-1]; //Initializing position arrays

    float[] yDist = new float[sizeof(yVel)-1];

    float[] zDist = new float[sizeof(zVel)-1];

    xDist[0] = xDist0;

    yDist[0] = yDist0;

    zDist[0] = zDist0;

   

    float[] xThe = new float[sizeof(xOme)-1]; //Initializing angle arrays

    float[] yThe = new float[sizeof(yOme)-1];

    float[] zThe = new float[sizeof(zOme)-1];

    xThe[0] = xThe0;

    yThe[0] = yThe0;

    zThe[0] = zThe0;

   

    for(int i = 1; i < (sizeof(xOme)-2); i++) //Calculates angle for absolute acceleration

    {

        xThe[i+1] = xThe[i] + 0.5*t*(xOme[i] + xOme[i+1]);

        yThe[i+1] = yThe[i] + 0.5*t*(yOme[i] + yOme[i+1]);

        zThe[i+1] = zThe[i] + 0.5*t*(zOme[i] + zOme[i+1]);

    }   

    

    for(int i = 1; i < (sizeof(xAcc)-1); i++) //Calculates absolute acceleration at each time point

    {

        float[][] acca1 = {{cos(zThe[i]*PI/180), sin(zThe[i]*PI/180), 0}, {-sin(zThe[i]*PI/180), cos(zThe[i]*PI/180), 0},  {0 0 1}}:

        float[][] acca2 = {{cos(yThe[i]*PI/180), 0, -sin(yThe[i])*PI/180}, {0, 1, 0}, {sin(yThe[i]*PI/180), 0, cos(yThe[i]*PI/180)}};

        float[][] acca3 = {{1, 0, 0}, {0, cos(xThe[i]*PI/180), sin(xThe[i]*PI/180)}, {0, -sin(xThe[i]*PI/180), cos(xThe[i]*PI/180)}};

        float[][] acc = {{xAcc[i]}, {yAcc[i]}, {zAcc[i]}};

       

        float[][] acca = acca1*acca2*acca3*acc; //Matrix multiplication to transform to an absolute axis

       

        //acca2 = [cosd(yThe) 0 -sind(yThe); 0 1 0; sind(yThe) 0 cosd(yThe)]*acca1; %Tracks second rotation with y rotation

        //acca3 = [1 0 0; 0 cosd(xThe) sind(xThe); 0 -sind(xThe) cosd(xThe)]*acca2; %Tracks final rotation with x rotation

        xAcca[i] = acca[1];

        yAcca[i] = acca[2];

        zAcca[i] = acca[3];

    }

 

   

    for(int i = 1; i < (sizeof(xAcca)-2); i++) //Calculates velocity at each time point

    {

        xVel[i+1] = xVel[i] + 0.5*t*(xAcca[i] + xAcca[i+1]);

        yVel[i+1] = yVel[i] + 0.5*t*(yAcca[i] + yAcca[i+1]);

        zVel[i+1] = zVel[i] + 0.5*t*(zAcca[i] + zAcca[i+1]);

    }

   

    for(int i = 1; i < (sizeof(xVel)-2); i++) //alculates distance, angle at each time point

    {

        xDist[i+1] = xDist[i] + 0.5*t*(xVel[i] + xVel[i+1]);

        yDist[i+1] = yDist[i] + 0.5*t*(yVel[i] + yVel[i+1]);

        zDist[i+1] = zDist[i] + 0.5*t*(zVel[i] + zVel[i+1]);

    }

    float time = t*(sizeof(xDist)); //total time of flight

   

    float apogee = 0;

    for(int i = 0; i < sizeof(zDist) - 1; i++)

    {

      if(apogee < zDist[i])

      {

        apogee = zDist[i]

      }

    }

    float[] finCoords = {xDist[sizeof(xDist)-1], yDist[sizeof(yDist)-1], zDist[sizeof(zDist)-1]}; //Final location -- x, y, z coordinate

   

    

    //xOff = -250; //x and y offset of launchpad from gridded image origin. Enter the x and y components of the distance offset.

    //yOff = 250;

 

    xLoc = floor((finCoords[1])+xOff)/250); //Finds the upper right-hand node of the cell that contains the location of the rocket

    yLoc = ceil((finCoords[2]+yOff)/250);

 

    cellID = 211 + xLoc - 20*yLoc; //Traces from origin to determine the cell number. Can be calculated.

    return cellID;

  }
